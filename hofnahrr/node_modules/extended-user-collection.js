/**
 * @file extended-user-collection.js
 * @description Extends the default deployd user collection with some
 * functionality to use Googe OpenID for login.
 */

var validation = require('deployd/node_modules/validation')
  , util = require('util')
  , UserCollection = require('deployd/lib/resources/user-collection')
  , db = require('deployd/lib/db')
  , EventEmitter = require('events').EventEmitter
  , uuid = require('deployd/lib/util/uuid')
  , crypto = require('crypto')
  , https = require('https')
  , SALT_LEN = 256
  , debug = require('deployd/node_modules/debug')('user-collection');

/**
 * A `UserCollection` adds user authentication to the Collection resource.
 *
 * Settings:
 *
 *   - `path`                the base path a resource should handle
 *   - `config.properties`   the properties of objects the collection should store 
 *   - `db`                  the database a collection will use for persistence
 *
 * @param {Object} options
 */

function ExtendedUserCollection(name, options) {
    UserCollection.apply(this, arguments);

    var config = this.config;

    if (!this.properties) {
        this.properties = {};
    }

    // username and password are required
    this.properties.username = this.properties.username || {type: 'string'};
    this.properties.username.required = true;
    this.properties.password = this.properties.password || {type: 'string'};
    this.properties.password.required = false;
}
util.inherits(ExtendedUserCollection, UserCollection);

ExtendedUserCollection.dashboard = UserCollection.dashboard;
ExtendedUserCollection.events    = UserCollection.events;

/**
 * Handle an incoming http `req` and `res` and execute
 * the correct `Store` proxy function based on `req.method`.
 *
 *
 * @param {ServerRequest} req
 * @param {ServerResponse} res
 */

ExtendedUserCollection.prototype.handle = function (ctx) {
    var uc = this;

    if (ctx.req.method === 'GET' && (ctx.url === '/count' || ctx.url.indexOf('/index-of') === 0)) {
        return UserCollection.prototype.handle.apply(uc, arguments);
    }

    if (ctx.url === '/logout') {
        if (ctx.res.cookies) {
            ctx.res.cookies.set('sid', null);
        }
        ctx.session.remove(ctx.done);
        return;
    }

    // set id one wasnt provided in the query
    ctx.query.id = ctx.query.id || this.parseId(ctx) || (ctx.body && ctx.body.id);

    // make sure password will never be included
    if (ctx.query.$fields) {
        ctx.query.$fields.password = 0;
    }
    else {
        ctx.query.$fields = {password: 0};
    }

    switch (ctx.req.method) {
    case 'GET':
        if (ctx.url === '/me') {
            debug('session %j', ctx.session.data);
            if (!(ctx.session && ctx.session.data && ctx.session.data.uid)) {
                ctx.res.statusCode = 204;
                return ctx.done();
            }
            
            ctx.query = {id: ctx.session.data.uid, $fields: {password: 0}};
            
            return this.find(ctx, ctx.done);
        }
        else if (ctx.url === '/openid_verify') {
            this._verifyOpenId(ctx, uc);            
        }

        this.find(ctx, ctx.done);
        break;
    case 'POST':
        if (ctx.url === '/login') {
            this._login(ctx, uc);
            break;
        }
        else if (ctx.url === '/openid-login') {
            this._openIdLogin(ctx, uc);
            break;
        }
    /* falls through */
    case 'PUT':
        if (ctx.body && ctx.body.password) {
            var salt = uuid.create(SALT_LEN);
            ctx.body.password = salt + this.hash(ctx.body.password, salt);
        }
        var isSelf = ctx.session.user && ctx.session.user.id === ctx.query.id || ctx.body.id;
        if ((ctx.query.id || ctx.body.id) && ctx.body && !isSelf && !ctx.session.isRoot && !ctx.req.internal) {
            delete ctx.body.username;
            delete ctx.body.password;
        }

        function done(err, res) {
            if (res) {
                delete res.password;
            }
            ctx.done(err, res);  
        }

        if (ctx.query.id || ctx.body.id) {
            this.save(ctx, done);
        } else {
            this.store.first({username: ctx.body.username}, function (err, u) {
                if (u) {
                    return ctx.done({errors: {username: 'is already in use'}});
                }
                uc.save(ctx, done);  
            });
        }
        break;
    case 'DELETE':
        debug('removing', ctx.query, ctx.done);
        this.remove(ctx, ctx.done);
        break;
    }
};

ExtendedUserCollection.prototype._openIdLogin = function (ctx, uc) {
    var body = ctx.body,
        realm = ctx.query.realm || 'http://hofnahrr.de:2403/',
        options = {
            host: 'www.google.com',
            port: 443,
            path: '/accounts/o8/id',
            method: 'GET',
            headers : {
                'Accept' : 'application/xrds+xml'
            }
        },
        req;

    req = https.request(options, function (res) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
            // find the URI tag
            var uri = (/<URI>([^<]+)<\/URI>/g.exec(chunk))[1],
                assocHandle = Math.random().toString(36).substr(2,16);
            
            uri += 
                '?openid.ns=http://specs.openid.net/auth/2.0' + 
                '&openid.mode=checkid_setup' + 
                '&openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select' + 
                '&openid.identity=http://specs.openid.net/auth/2.0/identifier_select' + 
                '&openid.assoc_handle=' + assocHandle +
                '&openid.realm=' + realm + 
                '&openid.ns.ax=http://openid.net/srv/ax/1.0' + 
                '&openid.ax.mode=fetch_request' + 
                '&openid.ax.type.attr=http://axschema.org/contact/country/home' + 
                '&openid.ax.type.attr1=http://axschema.org/contact/email' + 
                '&openid.ax.type.attr2=http://axschema.org/namePerson/first' + 
                '&openid.ax.type.attr3=http://axschema.org/namePerson/last' + 
                '&openid.ax.type.attr4=http://axschema.org/pref/language' + 
                '&openid.ax.type.attr5=http://schemas.openid.net/ax/api/user_id' + 
                '&openid.ax.required=attr,attr1,attr2,attr3,attr4,attr5' + 
                '&openid.ns.ui=http://specs.openid.net/extensions/ui/1.0' + 
                '&openid.return_to=' + realm + 'users/openid_verify?continue%3D' + realm + '#sight/';


            ctx.res.writeHeader(302, {'Location' : uri});
            ctx.res.end();
            
        });
    });

    req.on('error', function(e) {
        console.log('problem with request: ' + e.message);
    });

    req.end();
};

ExtendedUserCollection.prototype._verifyOpenId = function (ctx, uc) {
    var that = this,
        path = this.path,
        query = ctx.query,
        redirectTo = query.continue,
        country = query['openid.ext1.value.attr'],
        uid = query['openid.ext1.value.attr5'],
        data = {
            body : {
                username : query['openid.ext1.value.attr1'],
                email : query['openid.ext1.value.attr1'],
                firstname : query['openid.ext1.value.attr2'],
                surname : query['openid.ext1.value.attr3'],
                language : query['openid.ext1.value.attr4']
            }
        },
        done = function (user) {
            ctx.session.set({path: path, uid: user.id}).save(function () {
                ctx.res.writeHeader(302, {'Location' : redirectTo});
                ctx.res.end();
            });
        };

    this.store.first({'email' : data.body.email}, function (err, user) {
        if (err) {
            return ctx.done(err);
        }

        if (user) {
            done(user);
        } 
        else {
            that.save(data, function (something, user) {
                done(user);
            });
        }
    });

};

ExtendedUserCollection.prototype._login = function (ctx, uc) {
    var path = this.path
    , credentials = ctx.req.body || {};

    debug('trying to login as %s', credentials.username);

    this.store.first({username: credentials.username}, function (err, user) {
        if (err) {
            return ctx.done(err);
        }

        if (user) {
            var salt = user.password.substr(0, SALT_LEN)
            , hash = user.password.substr(SALT_LEN);

            if (hash === uc.hash(credentials.password, salt)) {
                debug('logged in as %s', credentials.username);
                ctx.session.set({path: path, uid: user.id}).save(ctx.done);
                return;
            }
        }

        ctx.res.statusCode = 401;
        ctx.done('bad credentials');
    });
};

ExtendedUserCollection.prototype.handleSession = function (ctx, fn) {
    // called when any session has been created
    var session = ctx.session
        , path = this.path;
        
    if (session && session.data && session.data.path == path && session.data.uid) {
        this.store.find({id: session.data.uid, $fields: {password: 0}}, function(err, user) {
            session.user = user;
            fn(err);
        });
    } else {
        fn();
    }
};

ExtendedUserCollection.prototype.hash = function (password, salt) {
    return crypto.createHmac('sha256', salt).update(password).digest('hex');
};

ExtendedUserCollection.label = 'Exteded Users Collection';
ExtendedUserCollection.defaultPath = '/users';

ExtendedUserCollection.prototype.clientGenerationGet = ['me'];
ExtendedUserCollection.prototype.clientGenerationExec = ['login', 'logout'];

module.exports = ExtendedUserCollection;
